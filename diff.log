diff --git a/fork.go b/fork.go
new file mode 100644
index 00000000..fb85d5c7
--- /dev/null
+++ b/fork.go
@@ -0,0 +1,205 @@
+// +build linux
+
+package main
+
+/*
+#include <arpa/inet.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+char errmsg[1024];
+
+int
+sendfds(int s, int *fds, int fdcount) {
+	char buf[1];
+	struct iovec iov;
+	struct msghdr header;
+	struct cmsghdr *cmsg;
+	int n;
+	char cms[CMSG_SPACE(sizeof(int) * fdcount)];
+
+	buf[0] = 0;
+	iov.iov_base = buf;
+	iov.iov_len = 1;
+
+	memset(&header, 0, sizeof header);
+	header.msg_iov = &iov;
+	header.msg_iovlen = 1;
+	header.msg_control = (caddr_t)cms;
+	header.msg_controllen = CMSG_LEN(sizeof(int) * fdcount);
+
+	cmsg = CMSG_FIRSTHDR(&header);
+	cmsg->cmsg_len = CMSG_LEN(sizeof(int) * fdcount);
+	cmsg->cmsg_level = SOL_SOCKET;
+	cmsg->cmsg_type = SCM_RIGHTS;
+	memmove(CMSG_DATA(cmsg), fds, sizeof(int) * fdcount);
+
+	if((n = sendmsg(s, &header, 0)) != iov.iov_len) {
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+sendRootFD(char *sockPath, int chrootFD) {
+	// Connect to server via socket.
+	int s, len, ret;
+	struct sockaddr_un remote;
+
+	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
+		return -1;
+	}
+
+	remote.sun_family = AF_UNIX;
+	strcpy(remote.sun_path, sockPath);
+	len = strlen(remote.sun_path) + sizeof(remote.sun_family);
+	if (connect(s, (struct sockaddr *)&remote, len) == -1) {
+		return -1;
+	}
+
+	int fds[1];
+	fds[0] = chrootFD;
+	if (sendfds(s, fds, 1) == -1) {
+		return -1;
+	}
+
+	char pid_arr[20];
+	if (read(s, pid_arr, 20) < 0) {
+		return -1;
+	}
+
+	int pid = atoi(pid_arr);
+
+	if(close(s) == -1) {
+		return -1;
+	}
+
+	return pid;
+}
+*/
+import "C"
+
+import (
+	"fmt"
+	"os"
+	"path/filepath"
+	"unsafe"
+
+	securejoin "github.com/cyphar/filepath-securejoin"
+	"github.com/opencontainers/runc/libcontainer"
+	"github.com/opencontainers/runc/libcontainer/utils"
+	"github.com/urfave/cli"
+)
+
+var forkCommand = cli.Command{
+	Name:  "fork",
+	Usage: "fork a container",
+	ArgsUsage: `<container-id>
+
+	Where "<container-id>" is your name for the instance of the container that you
+	are starting. The name you provide for the container instance must be unique on
+	your host.`,
+	Description: `test`,
+	Flags: []cli.Flag{
+		cli.StringFlag{
+			Name:  "bundle, b",
+			Value: "",
+			Usage: `path to the root of the bundle directory, defaults to the current directory`,
+		},
+	},
+	Action: func(context *cli.Context) error {
+		container, err := getContainer(context)
+		if err != nil {
+			return err
+		}
+
+		newContainerRootfs := context.String("bundle")
+		newContainerRootfs = filepath.Join(newContainerRootfs, "rootfs")
+		newContainerRootfsFd, err := os.Open(newContainerRootfs)
+		if err != nil {
+			return err
+		}
+		defer newContainerRootfsFd.Close()
+
+		state, err := container.State()
+		bundle, _ := utils.Annotations(state.Config.Labels)
+		socketName := context.Args()[1]
+		newContainerID := context.Args()[2]
+		newLinuxContainer, err := loadDefaultContainer(context, newContainerID)
+		if err != nil {
+			return err
+		}
+		cgroupsManager := (*newLinuxContainer).GetCgroupsManager()
+		fmt.Println(bundle)
+		socketPath, err := securejoin.SecureJoin(bundle, socketName)
+		if err != nil {
+			return err
+		}
+		pid, err := invoke(socketPath, newContainerRootfsFd)
+		if err != nil {
+			return err
+		}
+		// fmt.Println(pid)
+		// fmt.Println("begin applying cgroups")
+
+		err = (*cgroupsManager).Apply(pid)
+		if err != nil {
+			return err
+		}
+
+		err = (*newLinuxContainer).InitializeFakeContainer(pid)
+		if err != nil {
+			return err
+		}
+
+		config := (*newLinuxContainer).Config()
+		err = (*newLinuxContainer).Set(config)
+		if err != nil {
+			return err
+		}
+
+		/*newContainerState, err := (*newLinuxContainer).State()
+		if err != nil {
+			return err
+		}
+		if newContainerStateString, err := json.Marshal(newContainerState); err == nil {
+			fmt.Println(string(newContainerStateString))
+		} else {
+			return err
+		}*/
+
+		return nil
+	},
+}
+
+func invoke(socketPath string, rootDir *os.File) (int, error) {
+	cSock := C.CString(socketPath)
+	defer C.free(unsafe.Pointer(cSock))
+	pid, err := C.sendRootFD(cSock, C.int(rootDir.Fd()))
+	if err != nil {
+		return -1, err
+	}
+	return int(pid), nil
+}
+
+func loadDefaultContainer(context *cli.Context, id string) (*libcontainer.Container, error) {
+	spec, err := setupSpec(context)
+	if err != nil {
+		return nil, err
+	}
+	fmt.Printf("create a new container %s\n", id)
+	container, err := createContainer(context, id, spec)
+	if err != nil {
+		return nil, err
+	}
+	return &container, nil
+}
diff --git a/fork2container.go b/fork2container.go
new file mode 100644
index 00000000..a05718a7
--- /dev/null
+++ b/fork2container.go
@@ -0,0 +1,206 @@
+// +build linux
+
+package main
+
+/*
+#include <arpa/inet.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+int
+sendfds(int s, int *fds, int fdcount); // defined in fork.go
+
+// Send multiple FDs to the unix socket
+int
+sendMultipleFDs(char *sockPath, int chrootFD, int utsNamespaceFD, int pidNamespaceFD, int ipcNamespaceFD, int mntNamespaceFD) {
+	// Connect to server via socket.
+	int s, len, ret;
+	struct sockaddr_un remote;
+
+	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
+		return -1;
+	}
+
+	remote.sun_family = AF_UNIX;
+	strcpy(remote.sun_path, sockPath);
+	len = strlen(remote.sun_path) + sizeof(remote.sun_family);
+	if (connect(s, (struct sockaddr *)&remote, len) == -1) {
+		return -1;
+	}
+
+	int fds[5];
+	fds[0] = chrootFD;
+	fds[1] = utsNamespaceFD;
+	fds[2] = pidNamespaceFD;
+	fds[3] = ipcNamespaceFD;
+	fds[4] = mntNamespaceFD;
+
+	if (sendfds(s, fds, 5) == -1) {
+		return -1;
+	}
+
+	char pid_arr[20];
+	if (read(s, pid_arr, 20) < 0) {
+		return -1;
+	}
+
+	int pid = atoi(pid_arr);
+
+	if(close(s) == -1) {
+		return -1;
+	}
+
+	return pid;
+}
+*/
+import "C"
+
+import (
+	"errors"
+	"fmt"
+	"os"
+	"unsafe"
+
+	securejoin "github.com/cyphar/filepath-securejoin"
+	"github.com/opencontainers/runc/libcontainer/utils"
+	"github.com/urfave/cli"
+)
+
+var fork2ContainerCommand = cli.Command{
+	Name:        "fork2container",
+	Usage:       "fork a process and land it in a container",
+	ArgsUsage:   `TODO`,
+	Description: `TODO`,
+	Flags: []cli.Flag{
+		cli.StringFlag{
+			Name:  "zygote",
+			Value: "",
+			Usage: `the container ID of the zygote container`,
+		},
+		cli.StringFlag{
+			Name:  "target",
+			Value: "",
+			Usage: `the container ID of the target container to land the new process`,
+		},
+		cli.StringFlag{
+			Name:  "fork-socket",
+			Value: "rootfs/fork.sock",
+			Usage: `the relative path to the fork socket in the zygote container according to the bundle path`,
+		},
+	},
+	Action: func(context *cli.Context) error {
+		targetContainerID := context.String("target")
+		if targetContainerID == "" {
+			return errors.New("target container not specified")
+		}
+		zygoteContainerID := context.String("zygote")
+		if zygoteContainerID == "" {
+			return errors.New("zygote container not specified")
+		}
+		forkSocketPath := context.String("fork-socket")
+		if forkSocketPath == "" {
+			return errors.New("fork socket not specified")
+		}
+		targetContainer, err := getContainerByID(context, targetContainerID)
+		if err != nil {
+			return err
+		}
+		zygoteContainer, err := getContainerByID(context, zygoteContainerID)
+		if err != nil {
+			return err
+		}
+		targetCgroupManager := targetContainer.GetCgroupsManager()
+		if targetCgroupManager == nil {
+			return errors.New("cgroups manager is nil")
+		}
+		targetContainerState, err := targetContainer.State()
+		if err != nil {
+			return err
+		}
+		zygoteContainerState, err := zygoteContainer.State()
+		if err != nil {
+			return err
+		}
+		if targetContainerState == nil {
+			return errors.New("container state is nil")
+		}
+		// fmt.Println(targetContainerState.InitProcessPid)
+
+		// Open required namespace fds
+		utsNamespace := "/proc/" + fmt.Sprint(targetContainerState.InitProcessPid) + "/ns/uts"
+		pidNamespace := "/proc/" + fmt.Sprint(targetContainerState.InitProcessPid) + "/ns/pid"
+		ipcNamespace := "/proc/" + fmt.Sprint(targetContainerState.InitProcessPid) + "/ns/ipc"
+		mntNamespace := "/proc/" + fmt.Sprint(targetContainerState.InitProcessPid) + "/ns/mnt"
+		utsNamespaceFd, err := os.Open(utsNamespace)
+		if err != nil {
+			return err
+		}
+		defer utsNamespaceFd.Close()
+		pidNamespaceFd, err := os.Open(pidNamespace)
+		if err != nil {
+			return err
+		}
+		defer pidNamespaceFd.Close()
+		ipcNamespaceFd, err := os.Open(ipcNamespace)
+		if err != nil {
+			return err
+		}
+		defer ipcNamespaceFd.Close()
+		mntNamespaceFd, err := os.Open(mntNamespace)
+		if err != nil {
+			return err
+		}
+		defer mntNamespaceFd.Close()
+
+		targetContainerBundle, _ := utils.Annotations(targetContainerState.Config.Labels)
+		targetContainerRootfs, err := securejoin.SecureJoin(targetContainerBundle, "rootfs")
+		if err != nil {
+			return err
+		}
+		// fmt.Println(targetContainerRootfs)
+		targetContainerRootfsFd, err := os.Open(targetContainerRootfs)
+		if err != nil {
+			return err
+		}
+		defer targetContainerRootfsFd.Close()
+
+		// Find the path to the zygote container fork socket
+		zygoteContainerBundle, _ := utils.Annotations(zygoteContainerState.Config.Labels)
+		zygoteContainerForkSocketPath, err := securejoin.SecureJoin(zygoteContainerBundle, forkSocketPath)
+		// fmt.Println(zygoteContainerForkSocketPath)
+
+		// Send the fds to the socket
+		pid, err := invokeMultipleFDs(zygoteContainerForkSocketPath, targetContainerRootfsFd, utsNamespaceFd, pidNamespaceFd, ipcNamespaceFd, mntNamespaceFd)
+		if err != nil {
+			return err
+		}
+		// fmt.Println(pid)
+		// t0 := time.Now().UnixNano()
+		err = (*targetCgroupManager).Apply(pid)
+		if err != nil {
+			return err
+		}
+		// t1 := time.Now().UnixNano()
+		// fmt.Println(pid, " after applying the cgroups")
+		// fmt.Println(t1 - t0)
+		return nil
+	},
+}
+
+func invokeMultipleFDs(socketPath string, rootDir *os.File, utsNamespaceFd *os.File, pidNamespaceFd *os.File, ipcNamespaceFd *os.File, mntNamespaceFd *os.File) (int, error) {
+	cSock := C.CString(socketPath)
+	defer C.free(unsafe.Pointer(cSock))
+	pid, err := C.sendMultipleFDs(cSock, C.int(rootDir.Fd()), C.int(utsNamespaceFd.Fd()), C.int(pidNamespaceFd.Fd()), C.int(ipcNamespaceFd.Fd()), C.int(mntNamespaceFd.Fd()))
+	if err != nil {
+		return -1, err
+	}
+	return int(pid), nil
+}
diff --git a/libcontainer/container_linux.go b/libcontainer/container_linux.go
index 65e2eace..7ddfb5ee 100644
--- a/libcontainer/container_linux.go
+++ b/libcontainer/container_linux.go
@@ -140,6 +140,12 @@ type Container interface {
 	// errors:
 	// Systemerror - System error.
 	NotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error)
+
+	// GetCgroupsManager return a cgroups.Manager
+	GetCgroupsManager() *cgroups.Manager
+
+	// InitializeFakeContainer uses a running process's pid to initialize the data structure
+	InitializeFakeContainer(pid int) error
 }
 
 // ID returns the container's unique ID
@@ -677,6 +683,25 @@ func (c *linuxContainer) NotifyMemoryPressure(level PressureLevel) (<-chan struc
 	return notifyMemoryPressure(c.cgroupManager.Path("memory"), level)
 }
 
+func (c *linuxContainer) GetCgroupsManager() *cgroups.Manager {
+	return &c.cgroupManager
+}
+
+func (c *linuxContainer) InitializeFakeContainer(pid int) error {
+	if c.initProcess != nil {
+		return nil
+	}
+	init := &fakeProcess{}
+	init.processID = pid
+	c.initProcess = init
+	initProcessStartTime, err := init.startTime()
+	if err != nil {
+		return err
+	}
+	c.initProcessStartTime = initProcessStartTime
+	return nil
+}
+
 var criuFeatures *criurpc.CriuFeatures
 
 func (c *linuxContainer) checkCriuFeatures(criuOpts *CriuOpts, rpcOpts *criurpc.CriuOpts, criuFeat *criurpc.CriuFeatures) error {
@@ -1838,6 +1863,7 @@ func (c *linuxContainer) runType() Status {
 	pid := c.initProcess.pid()
 	stat, err := system.Stat(pid)
 	if err != nil {
+		logrus.Error(err)
 		return Stopped
 	}
 	if stat.StartTime != c.initProcessStartTime || stat.State == system.Zombie || stat.State == system.Dead {
diff --git a/libcontainer/process_linux.go b/libcontainer/process_linux.go
index 6f282877..935cd44a 100644
--- a/libcontainer/process_linux.go
+++ b/libcontainer/process_linux.go
@@ -674,3 +674,57 @@ func (p *Process) InitializeIO(rootuid, rootgid int) (i *IO, err error) {
 	}
 	return i, nil
 }
+
+type fakeProcess struct {
+	processID int
+}
+
+func (p *fakeProcess) pid() int {
+	return p.processID
+}
+
+func (p *fakeProcess) start() error {
+	return nil
+}
+
+func (p *fakeProcess) terminate() error {
+	// TODO
+	return nil
+}
+
+func (p *fakeProcess) wait() (*os.ProcessState, error) {
+	// TODO
+	return nil, nil
+}
+
+func (p *fakeProcess) startTime() (uint64, error) {
+	stat, err := system.Stat(p.pid())
+	return stat.StartTime, err
+}
+
+func (p *fakeProcess) signal(sig os.Signal) error {
+	s, ok := sig.(unix.Signal)
+	if !ok {
+		return errors.New("os: unsupported signal type")
+	}
+	return unix.Kill(p.pid(), s)
+}
+
+func (p *fakeProcess) externalDescriptors() []string {
+	// TODO
+	return nil
+}
+
+func (p *fakeProcess) setExternalDescriptors(fds []string) {
+	// TODO
+	return
+}
+
+func (p *fakeProcess) forwardChildLogs() {
+	// TODO
+	return
+}
+
+func (p *fakeProcess) SetFakeProcessID(pid int) {
+	p.processID = pid
+}
diff --git a/main.go b/main.go
index 57d7f428..4d7d020d 100644
--- a/main.go
+++ b/main.go
@@ -132,6 +132,8 @@ func main() {
 		startCommand,
 		stateCommand,
 		updateCommand,
+		forkCommand,
+		fork2ContainerCommand,
 	}
 	app.Before = func(context *cli.Context) error {
 		if !context.IsSet("root") && xdgRuntimeDir != "" {
diff --git a/utils_linux.go b/utils_linux.go
index 8241d423..8ebc100e 100644
--- a/utils_linux.go
+++ b/utils_linux.go
@@ -89,6 +89,17 @@ func getContainer(context *cli.Context) (libcontainer.Container, error) {
 	return factory.Load(id)
 }
 
+func getContainerByID(context *cli.Context, id string) (libcontainer.Container, error) {
+	if id == "" {
+		return nil, errEmptyID
+	}
+	factory, err := loadFactory(context)
+	if err != nil {
+		return nil, err
+	}
+	return factory.Load(id)
+}
+
 func getDefaultImagePath(context *cli.Context) string {
 	cwd, err := os.Getwd()
 	if err != nil {
